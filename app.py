import os
import json
import pickle
import joblib
import pandas as pd
from flask import Flask, jsonify, request


with open(os.path.join('columns.json')) as fh:
    columns = json.load(fh)

with open(os.path.join('dtypes.pickle'), 'rb') as fh:
    dtypes = pickle.load(fh)

with open(os.path.join('pipeline.pickle'), 'rb') as fh:
    pipeline = joblib.load(fh)

# Initialization code
feature_possible_values = {'workclass': ['Private',
  'Self-emp-inc',
  'Local-gov',
  'Federal-gov',
  '?',
  'State-gov',
  'Self-emp-not-inc',
  'Never-worked',
  'Without-pay'],
 'education': ['11th',
  'Bachelors',
  'HS-grad',
  'Assoc-voc',
  'Some-college',
  '5th-6th',
  '1st-4th',
  '10th',
  'Masters',
  'Doctorate',
  '7th-8th',
  '12th',
  '9th',
  'Assoc-acdm',
  'Prof-school',
  'Preschool'],
 'marital-status': ['Never-married',
  'Married-civ-spouse',
  'Widowed',
  'Divorced',
  'Married-spouse-absent',
  'Separated',
  'Married-AF-spouse'],
 'race': ['White',
  'Black',
  'Other',
  'Amer-Indian-Eskimo',
  'Asian-Pac-Islander'],
 'sex': ['Male', 'Female']}

all_features = [
    "age",
    "workclass",
    "education",
    "marital-status",
    "race",
    "sex",
    "capital-gain",
    "capital-loss", 
    "hours-per-week"
]

numerical_features = [
    "age", 
    "capital-gain",
    "capital-loss",
    "hours-per-week"
]

categorical_features = [feate for feate in all_features if feate not in numerical_features]

max_capital_gain = 99999
min_capital_gain = 0

max_capital_loss = 4356
min_capital_loss = 0

def predict_resp(request):
    """
    Produce prediction for request.
    
    Inputs:
        request: dictionary with format described below
        
        ```
        {
            "observation_id": <id-as-a-string>,
            "data": {
                "age": <value>,
                "sex": <value>,
                "race": <value>,
                "workclass": <value>,
                "education": <value>,
                "marital-status": <value>,
                "capital-gain": <value>,
                "capital-loss": <value>,
                "hours-per-week": <value>,
            }
        }
        ```
    
    Returns:
        response: A dictionary echoing the request and its data with the addition of the prediction and probability 
            ```
            {
                "observation_id": <id-of-request>,
                "age": <value-of-request>,
                "sex": <value-of-request>,
                "race": <value-of-request>,
                "workclass": <value-of-request>,
                "education": <value-of-request>,
                "marital-status": <value-of-request>,
                "capital-gain": <value-of-request>,
                "capital-loss": <value-of-request>,
                "hours-per-week": <value-of-request>,
                "prediction": <True|False>,
                "probability": <probability generated by model>
            }
            ```
    """
    obs_dict = request
    observation = obs_dict['data']
    obsservation_id = obs_dict['observation_id']

    obs = pd.DataFrame([observation], columns=columns).astype(dtypes)

    proba = pipeline.predict_proba(obs)[0, 1]

    response = observation.copy()
    response['observation_id'] = obsservation_id
    response['prediction'] = bool(proba > 0.5)
    response['probability'] = proba
    
    return response



def attempt_predict(request):
    """
    Produce prediction for request.
    
    Inputs:
        request: dictionary with format described below
        
        ```
        {
            "observation_id": <id-as-a-string>,
            "data": {
                "age": <value>,
                "sex": <value>,
                "race": <value>,
                "workclass": <value>,
                "education": <value>,
                "marital-status": <value>,
                "capital-gain": <value>,
                "capital-loss": <value>,
                "hours-per-week": <value>,
            }
        }
        ```
     
    Returns: A dictionary with predictions or an error, the two potential values:
                if the request is OK and was properly parsed and predicted:
                ```
                {
                    "observation_id": <id-of-request>,
                    "prediction": <True|False>,
                    "probability": <probability generated by model>
                }
                ```
                otherwise:
                ```
                {
                    "observation_id": <id-of-request>,
                    "error": "some error message"
                }
                ```
    """

    if ("observation_id" not in request.keys()):
        error = {
            "error": "observation_id must be provided",
            "observation_id": None
        }

        return error 

    obs_id = request['observation_id']
    
    if ("data" not in request.keys()):
        error = {
            "error": "data must be provided",
            "observation_id": obs_id
        }

        return error 

    data = request['data']

    for feature in all_features:
        if feature not in data.keys():
            error = {
                "error": feature + " must be provided",
                "observation_id": obs_id
            }


            return error 
    
    for col in data.keys():
        if col not in all_features:
            error = {
                "error": col + " is not recognized",
                "observation_id": obs_id
            }


            return error 
            
        if col in categorical_features and data[col] not in feature_possible_values[col]:
            error = {
                "error": data[col] + " is not recognized value for feature " + col,
                "observation_id": obs_id
            }


            return error 

    if data['age'] <= 0 or data['age'] > 100:
        error = {
            "error": str(data['age']) + " is not recognized value for feature age",
            "observation_id": obs_id
        }

        return error 
    
    if data['capital-gain'] < min_capital_gain or data['capital-gain'] > max_capital_gain:
        error = {
            "error": str(data['capital-gain']) + " is not recognized value for feature capital-gain",
            "observation_id": obs_id
        }

        return error 

    if data['capital-loss'] < min_capital_loss or data['capital-loss'] > max_capital_loss:
        error = {
            "error": str(data['capital-loss']) + " is not recognized value for feature capital-loss",
            "observation_id": obs_id
        }

        return error 

    if data['hours-per-week'] < 0 or data['hours-per-week'] > 7*24:
        error = {
            "error": str(data['hours-per-week']) + " is not recognized value for feature hours-per-week",
            "observation_id": obs_id
        }

        return error 

    
    return predict_resp(request)



########################################
# Begin webserver stuff

app = Flask(__name__)


@app.route('/predict', methods=['POST'])
def predict():
    # flask provides a deserialization convenience function called
    # get_json that will work if the mimetype is application/json
    obs_dict = request.get_json()
    
    return jsonify(attempt_predict(obs_dict))



# End webserver stuff
########################################

if __name__ == "__main__":
    app.run(debug=True, port=5000)
